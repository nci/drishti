#begin
menu Load Volume
Load .pvl.nc volumes.  Users can load upto 4 volumes for simultaneous viewing.  Each of these can be a series of volumes.

Users can drag-and-drop a single volume/series of volumes to load these.  To load multiple volumes for simultaneous viewing, users will have to use the Load Volume menu.
#end


#begin
menu Load Project
Projects in Drishti are stored as two files .xml and .keyframes.  The .xml file saves the global settings for the project and .keyframes file stores the individual keyframe information.  Use .xml file to load the project.

Users can drag-and-drop .xml file to load that project.
#end


#begin
menu Load Geometry
Users can view different geometry types with the volume data in Drishti.  Networks, trisets, paths and point sets can be viewed.  Users can drag-and-drop these files to load them.
#end


#begin
menu Import Transfer Functions from Project
Users can import/copy transfer functions from other projects into current project.  Only transfer functions specified in .xml file are imported, those that are in the accompanying .keyframes file are not imported.
#end


#begin
menu Import Keyframes
Import keyframe information from other project.  User will be asked to select information from the keyframes to import.
#end


#begin
menu Save Project
Save project to .xml file with keyframes stored in the accompanying .keyframes file.
#end


#begin
menu Save Image Sequence
Save image sequence.  User will be asked for the image size, the image sequence file name, start frame number, end frame number and step.

Users can save images in mono, stereo (2 images - left and right) or cubic format (6 images - front, back, left, right, top and bottom).
#end


#begin
menu Save Movie
Save movie in .wmv format (for Windows only).

Image width and height should be a multiple of 16.
#end

#begin
menu Toggle
The Toggle menu list various different options :

Status Bar - toggle progress bar at the bottom.

Shadow Render - toggle user defined shadow rendering.

Anaglyph Stereo - toggle red-blue/red-cyan anaglyph rendering

Axes - toggle display of X-Y-Z axes.

Bounding Box - toggle display of bounding box.

Depth Cue - toggle darkening of volume away from user.

Mouse Grab - toggle mouse grabbing, when hovered over, for various geometry widgets.

Visibility - toggle display of various geometry widgets.

2D Occlusion Spectrum Functions - toggle Occlusion Spectrum transfer functions.

1D Transfer Functions - toggle between 1D and 2D transfer functions.

Enable Mask - toggle volume masks.

Linear Texture Interpolation - toggle between linear and nearest neighbour interpolation for volume data.

Spline Position Interpolation - toggle between spline-based and linear interpolation for camera positions while animating camera positions.

Enable Bottom Text - toggle display of information text shown at the bottom of the image.

Skip Empty Region - toggle facility to skip empty regions in the volume.  Each time transfer function is changed the empty regions calculations are performed to determine regions that are transparent.  These regions are then skipped from rendering.  For dense data sets, it is advised to switch it off.

Render Quality - switch between finer to coarser render qualities.

Always high quality render - toggle use of normal volume even when in mouse drag mode.  Drishti loads two types of volumes into GPU texture memory - normal volume and highly subsampled drag volume.  Normally, while in mouse drag mode the subsampled drag volume is used to render the image.  When not in drag mode the normal volume is used to render the image.  This is done in order to maintain interactivity.


Use Drag Volume - toggle use of Drag Volume.  Drishti loads two types of volumes into GPU texture memory - normal volume and highly subsampled drag volume.  Normally, while in mouse drag mode the subsampled drag volume is used to render the image.  When not in drag mode the normal volume is used to render the image.  This is done in order to maintain interactivity.  This is useful when exploring at large volumes as well as in setting up the keyframes, before the final render.

Use Drag Volume for Shadows - toggle use of Drag Volume for shadow calculation - this might result in faster but lower quality shadows.

Flip Texture Coordinates - Switch the direction of texture coordinates.

#end


#begin
volume rendering in drishti
Drishti renders volumetric data using hardware texture based volume rendering method. The volume is loaded into texture memory of the graphics card. View aligned polygons are plotted and textured to generate the final image.

* Details *
When a preprocessed .pvl.nc file is supplied to Drishti, first a lower resolution version is generated by subsampling. The volume is subsampled till the entire subsampled volume fits inside 64Mb. This volume is loaded into a single 3D texture of the graphics card. The uploaded data is then rendered and shown in the lowres window.

When user presses F2 in order to switch to high resolution mode - Hires mode, the selected subvolume is loaded onto the texture memory of the graphics card.

The volume texture is loaded as a set of 2D textures (instead of a single 3D texture). The rationale behind loading data into 2D textures is to circumvent the power-of-2 texture size limitation on 3D textures in OpenGL. Each dimension of a 3D texture in OpenGL needs to be a power of 2. As against that, 2D textures in OpenGL can have non-power of 2 dimensions.

Graphics cards have limits on the maximum texture size - usually 4k x 4k or 8k x 8k. Z-slices in the volume are laid out in row-column fashion in the 2D textures. Size of the 2D texture is determined by the number of z-slices that can be fitted into the texture. It is highly likely that for most of the data sets a single texture is not enough to fit the entire selected subvolume. In this case the data is loaded in multiple 2D textures or slabs and the top and bottom z-slices for each 2D texture are replicated in order to maintain continuity.

Drishti tries to fit the selected subvolume into available texture memory. If this is not possible then a subsampled version is loaded. The degree of subsampling depends on the amount of texture memory and the subvolume size. This information is always displayed at the bottom in the Hires mode.

When the selected (and possibly subsampled) subvolume cannot be loaded into a single 2D texture, a (further) subsampled version of the subvolume is created to fit into a single 2D texture. This data is then used as drag volume, to be used whenever user is manipulating the volume by dragging the mouse.

#end

#begin
batch rendering
There are two ways of submitting a batch job :

    * specifying all options via command line.
    * specifying options in a file and providing the filename via command line. 

Only one job can be submitted at a time. Drishti will start with a render window and the rendering will start automatically. Users can minimize the window, this will not affect the rendering.

-----------------------------------------------------------------------
batch option		description
-----------------------------------------------------------------------
project		project=.xml project filename
		Specifies the project to be used.

renderframes		renderframes=start,end,step
		Specifies the frames to render. If not specified all
		the frames in the project are rendered.

image		image=image filename
		Specifies relative (to the project file) filename for images.
		For e.g. image=output/test$4f.png

movie		movie=movie filename
		Specifies relative (to the project file) filename for movie.
		If both image and movie are specified then only movie is stored.

framerate		framerate=fps
		Specifies framerate for movie. Default value is 25 frames
		per sec of movie.

imagemode		imagemode=[mono|stereo|cubic|redcyan|redblue]
		Specifies image mode for images as well as movie. Default is
		mono mode. When is stereo mode two sets of images/movies will
		be rendered. For cubic mode four sets will be rendered. For
		redcyan and redblue, only one set of anaglyph images/movie is rendered.

imagesize		imagesize=sizeX,sizeY
		Set image size for images as well as movie. Default is 720,576.

stepsize		stepsize=size
		Set the stepsize between layers for rendering. Default is 0.9.

shading		shading
		Turn on user shading mode. Default is no shading.

depthcue		depthcue
		Turn on depthcueing. Default is no depthcueing.

skipemptyspace	skipemptyspace
		Turn on pruning via empty space skipping. Default is no pruning.

dragonly		dragonly
		Load only low resolution drag volume which fits in a single
		2D texture for rendering. Default is not to use drag volume.

dragonlyforshadows	dragonlyforshadows
		Instead of using the higher resolution volume, use lower
		resolution drag volume for rendering shadows. Default is
		not to use drag volume.
-----------------------------------------------------------------------
-----------------------------------------------------------------------

Users can specify these options via command line. For e.g.
drishti -project=d:/VolumeData/TestData/test.xml -renderframes=1,100,2 -movie=test.wmv -shading

Alternatively users can specify these options in a text file with each option on a single line. This file is then supplied via command line :
drishti -file=batchfilename

Use # at the start of the line to ignore that line. For e.g.

-------------------------------------
	project = test.xml
	renderframes = 1, 1000, 3
	image = output/test$5f.png
	imagesize = 1900, 1080
	stepsize = 0.8
	shading
	#movie = test.wmv
	#framerate = 30
-------------------------------------

#end

#begin
occlusion spectrum
This newer way for volume classification and visualization is based on the work by Carlos D. Correa and Kwan-Liu Ma. Please refer to http://vis.cs.ucdavis.edu/~correac/docs/vis09.pdf for more details

I find 2D transfer functions with occlusion spectrum especially useful for noisy data.


* Details *

The main idea behind this way of implementing 2D transfer functions is to separate structures based on distribution of intensities in the neighbourhood. The value-gradient magnitude based 2D transfer function is very good to identifying material boundaries.

The implementation is simple :

    * Apply low pass filter to the volume.
    * Instead of gradient magnitude, use the filtered value as the second parameter for the 2D transfer function. 

In Drishti, the filtered volume will be generated when 2D Occlusion Spectrum Transfer Functions (o) is switched on via the Toggle menu. The filtered volume is saved in the files with extension .smooth.. These files have the same format as the .pvl.nc. files - first byte is 0, followed by 3 integers, followed by 1-byte per voxel data.

Mean filter of size 3x3x3 is applied as default. The size of the filter can be changed via command dialog. Press spacebar in the hires window to bring up command dialog. Enter spread value to change the (filter) spread size. The current spread value is displayed in the command dialog. The actual filter size is (2*spread+1).

2D histogram generated using this technique looks very different from that generated using gradient magnitude. Firstly notice that the homogeneous region is not necessary at the bottom, but will be lifted up closer to diagonal (depending on filter size). Also there may be smearing (or arches) on both the sides of homogeneous region. If some voxels have more lower intensity voxels in their neighbourhood then their position would be dragged lower, where as in the case of more neighbouring higher intensity voxels these would be dragged higher.

This filtered volume is loaded in texture memory separately from the voxel intensity data. The filtered data may have to be subsampled to fit in a single 2D texture - which is usually 4k x 4k or 8k x 8k (depending on graphics card).

Users can also create their own version of .smooth. file - which would allow users to classify data in a different fashion.


* Trial *

I am trialling a slightly different way - taking the difference of actual voxel value and respective smoothed value. This difference will be positive as well as negative. In order to show both of these the horizontal axis is shifted upwards. This way the homogeneous region always lies at midway region in the 2D histogram. 
#end

#begin
.pvl.nc file format
When a volume data is imported using the importer utility, it is converted into unsigned char if necessary. The drishti volume renderer uses this unsigned char data for visualization. The importer provides tools to increase the contrast of the data. The information generated from importer is written to .pvl.nc file which has xml format. This file saves the following information :

-----------------------------------------------------------------------
rawfile	name of the raw file for which the .pvl.nc file is generated.

description	information regarding the data.

voxeltype	unsigned char, char, unsigned short, short, int, float

voxelunit	no unit, angstrom, nanometer, micron, millimeter,
	centimeter, meter, kilometer, parsec, kiloparsec

voxelsize	three floats

gridsize	three ints

slabsize	number of slices per volume data file .pvl.nc.001,
	.pvl.nc.002 and so on. Currently the number of slices
	per file is such that each file is no bigger then 1Gb.
	This allows handling of large data sets even on 32-bit systems.

rawmap	list of raw values

pvlmap	list of unsigned char values
-----------------------------------------------------------------------

Following is an example of a typical .pvl.nc file.

-------------------------------------
	<!DOCTYPE Drishti_Header>
	<PvlDotNcFileHeader>
	  <rawfile>test.raw</rawfile>
	  <voxeltype>unsigned char</voxeltype>
	  <gridsize>161 108 115</gridsize>
	  <voxelunit>micron</voxelunit>
	  <voxelsize>1 1 1</voxelsize>
	  <description>Information about volume</description>
	  <slabsize>115</slabsize>
	  <rawmap>703 5000 12242 </rawmap>
	  <pvlmap>0 128 255 </pvlmap>
	</PvlDotNcFileHeader>
-------------------------------------

The actual volume data is stored in multiple files .pvl.nc.001, .pvl.nc.002 and so on. Each .pvl.nc.* file has a 13 byte header - first byte is 0 followed by three integers specifying number of slices in that file, width and height of slices. The volume data which follows has 1-byte per voxel - i.e. the raw-to-uchar mapped data.

The user is also asked whether to save .raw files while importing the data. If the .raw files are stored then these files also have a similar 13 byte header. The raw data which follows is the same from the original files.

Users do not have to go through the importer to create .pvl.nc files. It is not necessary to have the .pvl.nc.001, .pvl.nc.002, ... files. The files can have any names. These names though have to be provided via the .pvl.nc file. In that case the following tag mays be present in the .pvl.nc file :
-----------------------------------------------------------------------
rawnames		names of raw files

rawheadersize 	size of header (in bytes) in the raw file/s.
		Default is 13 bytes

pvlnames		names of .pvl.nc files

pvlheadersize 	size of header (in bytes) in the pvl file/s.
		Default is 13 bytes
-----------------------------------------------------------------------

Following is an example of a .pvl.nc file which uses the same set of files as rawnames as well as pvlnames. Note that the headersize is 0 for both raw as well as pvl.:

-------------------------------------
	<!DOCTYPE Drishti_Header>
	<PvlDotNcFileHeader>
	  <rawfile></rawfile>
	  <rawnames>vg1_8mm_0001.raw
	            vg1_8mm_0002.raw
	            vg1_8mm_0003.raw
	            vg1_8mm_0004.raw
	            vg1_8mm_0005.raw </rawnames>
	  <pvlnames>vg1_8mm_0001.raw
	            vg1_8mm_0002.raw
	            vg1_8mm_0003.raw
	            vg1_8mm_0004.raw
	            vg1_8mm_0005.raw </pvlnames>
	  <pvlheadersize>0</pvlheadersize>
	  <rawheadersize>0</rawheadersize>
	  <voxeltype>unsigned char</voxeltype>
	  <gridsize>1420 2043 1760</gridsize>
	  <voxelunit>no units</voxelunit>
	  <voxelsize>1 1 1</voxelsize>
	  <description>Information about volume</description>
	  <slabsize>298</slabsize>
	  <rawmap>0 255 </rawmap>
	  <pvlmap>0 255 </pvlmap>
	</PvlDotNcFileHeader>
-------------------------------------

#end

#begin
volume masks
Masks allow users to tag individual voxels (akin to segmentation). This tagging allows users to render portions of the volume in a different way or erase the portion. Tagging does not in any way modify the original volume, it is only rendering that is affected. Users can also calculate volume and surface areas of tagged portions.

This tag information is stored in separate files having the same name as the .pvl.nc file, but with .mask extension.

The .mask.* files has exactly the same format as .pvl.nc.* files. Please refer to file formats for detailed information.

Volume masks are activated using Enable Mask switch under the Toggle menu. Volume masks can be used only for single as well as multiple volumes, but not for RGB/RGBA volumes. The mask can only be modified for single volume.

By default the tag value for all the voxels is 0. Tag value of 255 implies erase - i.e. the voxels having tag value of 255 will not be rendered, same as erasing them (the original volume is not touched, it is only the rendering that is affected). Voxels having tag values between 1 and 250 are tinged with a different color, when these are shown using transfer functions. Voxels that have tag values between 251 and 254 are rendered with the given tinge color even when no transfer function is applied - in essence these voxel are always shown (when the tinge opacity is greater than zero). The tinge color and opacity is taken from Tag Colors found under Preferences widget. Tag opacities are used to mix tinge color with the underlying transfer function color. Tinge colors and opacities can be changed and animated. Drishti provides two major ways for tagging the volumetric data - 2D paint interface and 3D paintball interface . Users can also make use of paths (use fill/fillempty) for tagging regions. Clipplanes can be used to restrict the masking process.

-----------------------------------------------------------------------
Tag Value 	Description
-----------------------------------------------------------------------
0 	Apply transfer function without change.

1-250 	Apply transfer function by mixing appropriate tag color with tag
	opacity. If the tag color is pure black i.e all components of tag
	color are 0, then tag opacity is used to modulate voxel opacity. This
	feature can be used for reducing opacity of the region occluding
	important feature in the data set.

	if (tag .gt. 0 .and. tag .lt. 251)
	voxelColor = voxelColor*(1-tagOpacity) + tagColor*tagOpacity

	if (tagColor .eq. black)
	voxelOpacity = voxelOpacity*tagOpacity

251-254 	Show voxel with appropriate tag color and opacity.
-----------------------------------------------------------------------
#end

#begin
volume masks paint ball interface
Once the volume mask is activated 3D paintball can be used for tagging the voxels. Tagging via paintball is enabled only when mask is enabled. By default paintball is not shown. Use p to show the 3D paintball. The paintball is shown as a wireframe ellipsoid. It can be repositioned by dragging the center dot. Size can be changed by dragging the boundary dots. Whenever the paintball intersects visible region of the volume, this region is tinged with red color.

Paintball is activated by hovering mouse over the center of the paintball. Active paintball is shown in green. Once activated users can give single keystroke commands or by pressing spacebar can bring up command window.

Clipplanes can be used to restrict the masking process. 
#end

#begin
volume masks 2D paint interface
Once the volume mask is activated 2D paint interface can be used for tagging the voxels. Tagging via 2D paint interface is enabled only when mask is enabled. Compared to the 3D paintball interface , the 2D paint interface is easier to operate. This interface allows users to paint on the surface of the volume. Surface is defined by the transfer functions. Users can specify how deep the tagging process can proceed. Voxels beneath the surface can be tagged in this way.

Tab key is used to toggle 2D paint interface. When 2D interface is enabled the last image is frozen on the screen and user cannot reorient the image. The program captures depth information for that image, which is used for enabling painting on the surfaces. Blue line are drawn in the high gradient areas. Areas where users cannot paint are colored in deep red. These are the areas where volume data is not rendered - it could be because of transfer functions or because of the limits of the data.

Turn off any geometry rendering - such as clip planes, bounding boxes etc.- before enabling 2D paint interface.

Once enabled a small menu will appear on the top-left corner of the image. The menu will list current Tag, Thickness (how far deep the tagging process can go), Paint Area : (Yes/No) (to paint using circular patch - Paint Area : Yes or to draw lines on the surface - Paint Area : No). When Paint Area is enabled Delta (depth difference threshold value) and Spread (radius of circular patch) are also displayed. Values of these variables can be changed by placing mouse on them and typing in the required values.

When Paint Area is "yes" a small green circular patch will follow the mouse, whenever it is on the surface as defined by transfer functions. The shape of this patch is dictated by difference between the depth values of point on the surface and the depth of point directly below the mouse, Delta (depth difference threshold value) and Spread (radius of the circular patch).

Use left mouse to paint a patch or draw lines. Right mouse is used for deselecing the patch. Users can color many patches/lines before deciding to proceed with tagging voxels. Use ESC key to clear all painted areas.

Clipplanes can be used to restrict the masking process. 

-----------------------------------------------------------------------
Key	Description
-----------------------------------------------------------------------
t (Tag)	Tag the voxels with current Tag value. How deep the tagging
	process goes is defined by the Thickness parameter. Voxels
	that are tagged are those that :
		1. lie directly under the shaded region.
		2. have opacity greater than zero.
		3. are connected to the surface painted voxels.
		4. no deeper from surface than the thickness value.
	Interior voxels are said to be connected to the surface voxels
	if there is a connection that lies entirely within the shaded
	region.

d (Drill)	This is flood-fill with seed points as the surface
	painted voxels. Tag the voxels with current Tag value. Thickness
	parameter has no bearing on the tagging process. Voxels that
	are tagged are those that :
		1. lie directly under the shaded region.
		2. have opacity greater than zero.
		3. are connected to the surface painted voxels.
	Interior voxels are said to be connected to the surface voxels
	if there is a connection that lies entirely within the
	shaded region.

f (Fill)	This is flood-fill with seed points as the surface
	painted voxels. Tag the voxels with current Tag value. Thickness
	parameter has no bearing on the tagging process. All the voxels
	connected to the surface painted voxels are tagged. Surface
	painting is used only for defining seed points for flood fill
	process and not for restricting the process to those voxels
	that lie directly underneath the shaded region. 
-----------------------------------------------------------------------

#end

#begin
help videos
Some help videos are available at
http://anusf.anu.edu.au/~acl900/tmp/help-videos/
http://anusf.anu.edu.au/Vizlab/drishti/help.shtml
#end